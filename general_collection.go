package handyCollection

import (
	"github.com/google/uuid"
	"math/rand"
	"sort"
	"time"
)

// ItemInfo 遍历Item信息
type ItemInfo[T any] struct {
	Item  T
	Index int
	Key   string
}

// GeneralCollection 通用集合
type GeneralCollection[T any] struct {
	items             map[string]T
	orderedKeys       []string        // 用于维持数据的有序性
	autoGeneratedKeys map[string]bool // 用于标记哪些item的key是自动生成的，这些key不会在覆盖到新产生的集合中(例如 Filter, Sort 这类方法所生成的新集合)
	keysIndex         map[string]int  // 用于通过key搜索其下标
	sliceCache        []T
	defaultItem       T
}

// NewGeneralCollection 创建GeneralCollection
func NewGeneralCollection[T any]() *GeneralCollection[T] {
	c := &GeneralCollection[T]{}
	c.defaultItem = c.items[""]
	c.init()

	return c
}

func (c *GeneralCollection[T]) init() {
	c.items = make(map[string]T)
	c.orderedKeys = make([]string, 0)
	c.autoGeneratedKeys = make(map[string]bool)
	c.keysIndex = nil
	c.sliceCache = nil
}

// Add 向集合中新增数据
func (c *GeneralCollection[T]) Add(items ...T) *GeneralCollection[T] {
	for _, each := range items {
		key := c.genKey()
		c.items[key] = each
		c.orderedKeys = append(c.orderedKeys, key)
		c.autoGeneratedKeys[key] = true
		c.setKeyIndex(key, len(c.orderedKeys)-1)
		c.tryAppendToSliceCache(each)
	}
	return c
}

// AddWithKey 向集合中新增数据，并与一个key关联,后续的操作中可以通过这个key获取到数据本身
// 如果集合中已经有数据关联了相同的key, 则会覆盖原有数据, 并保持数据所在的次序
func (c *GeneralCollection[T]) AddWithKey(item T, key string) *GeneralCollection[T] {
	_, hasKey := c.items[key]
	c.items[key] = item
	if !hasKey {
		c.orderedKeys = append(c.orderedKeys, key)
		c.setKeyIndex(key, len(c.orderedKeys)-1)
		c.tryAppendToSliceCache(item)
	} else {
		if idx, found := c.IndexByKey(key); found {
			c.trySetSliceCacheItem(idx, item)
		}
	}
	return c
}

// Merge 合并指定的集合的数据到该集合中
// 被合并的集合中如果数据向关联的key，那么合并后该数据项依旧关联该key, 如果当前集合中已经存在关联此key的数据项, 那么它会被覆盖
func (c *GeneralCollection[T]) Merge(collections ...*GeneralCollection[T]) *GeneralCollection[T] {
	for _, each := range collections {
		for _, key := range each.orderedKeys {
			item := each.items[key]
			if each.isAutoGenKey(key) {
				c.Add(item)
			} else {
				c.AddWithKey(item, key)
			}
		}
	}
	return c
}

// MergeSlices 合并slice中的数据到该集合中
func (c *GeneralCollection[T]) MergeSlices(slices ...[]T) *GeneralCollection[T] {
	for _, each := range slices {
		for _, item := range each {
			c.Add(item)
		}
	}
	return c
}

// MergeMaps 合并map中的数据到该集合中
// keepKeys为true时, map的key会作为集合搜索键的key
func (c *GeneralCollection[T]) MergeMaps(keepKeys bool, maps ...map[string]T) *GeneralCollection[T] {
	for _, each := range maps {
		for key, item := range each {
			if keepKeys {
				c.AddWithKey(item, key)
			} else {
				c.Add(item)
			}
		}
	}
	return c
}

// Clear 清空集合数据
func (c *GeneralCollection[T]) Clear() *GeneralCollection[T] {
	c.init()
	return c
}

// FindByIndex 通过下标找到数据项
// 下标允许传负数，它代表从集合尾部开始往回数, 例如-1标识最后一个数据项
// 如果没有找到数据项，那么第二个返回值为false, 否则为true
func (c *GeneralCollection[T]) FindByIndex(idx int) (T, bool) {
	idx, valid := c.actualIndex(idx)
	if !valid {
		return c.defaultItem, false
	}
	return c.FindByKey(c.orderedKeys[idx])
}

// FindByKey 通过关联key查找数据项
// 如果没有找到数据项，那么第二个返回值为false, 否则为true
func (c *GeneralCollection[T]) FindByKey(key string) (T, bool) {
	d, ok := c.items[key]
	return d, ok
}

// HasKey 是否有数据关联指定的key
func (c *GeneralCollection[T]) HasKey(key string) bool {
	_, ok := c.items[key]
	return ok
}

// KeyByIndex 返回该索引下数据项的关联key
// 与 FindByIndex 一样,下标允许传负数，
// 如果没有该索引，第二个返回值为false, 否则为true
func (c *GeneralCollection[T]) KeyByIndex(idx int) (string, bool) {
	idx, valid := c.actualIndex(idx)
	if !valid {
		return "", false
	}
	return c.orderedKeys[idx], true
}

// IndexByKey 返回关联该key的数据项的索引值
// 如果没有任何数据项关联该key, 第二个返回值为false, 否则为true
func (c *GeneralCollection[T]) IndexByKey(key string) (int, bool) {
	if c.keysIndex == nil {
		c.keysIndex = make(map[string]int)
		for idx, k := range c.orderedKeys {
			c.keysIndex[k] = idx
		}
	}
	idx, ok := c.keysIndex[key]
	return idx, ok
}

// Count 返回该集合中数据项的数量
func (c *GeneralCollection[T]) Count() int {
	return len(c.orderedKeys)
}

// RemoveByIndex 根据索引移除数据项
// 允许idx为负,即从末尾回数
// 返回true即移除成功，false时代表给定的idx超出范围.
func (c *GeneralCollection[T]) RemoveByIndex(idx int) (T, bool) {
	idx, valid := c.actualIndex(idx)
	if !valid {
		return c.defaultItem, false
	}

	lastIdx := len(c.orderedKeys) - 1
	key := c.orderedKeys[idx]
	item := c.items[key]
	delete(c.items, key)
	delete(c.autoGeneratedKeys, key)
	if idx == 0 {
		c.orderedKeys = c.orderedKeys[1:]
		c.deleteKeyIndex(key)
		if c.sliceCache != nil {
			c.sliceCache = c.sliceCache[1:]
		}
	} else if idx == lastIdx {
		c.orderedKeys = c.orderedKeys[:lastIdx]
		c.deleteKeyIndex(key)
		if c.sliceCache != nil {
			c.sliceCache = c.sliceCache[:lastIdx]
		}
	} else {
		copy(c.orderedKeys[idx:], c.orderedKeys[idx+1:])
		c.orderedKeys = c.orderedKeys[:lastIdx]
		c.clearKeysIndex()
		c.clearSliceCache()
	}
	return item, true
}

// RemoveByKey 根据搜索key移除数据项
// 返回true即移除成功; false代表key不存在
func (c *GeneralCollection[T]) RemoveByKey(key string) (T, bool) {
	idx, found := c.IndexByKey(key)
	if !found {
		return c.defaultItem, false
	}
	return c.RemoveByIndex(idx)
}

// Pop 从集合尾部移出一个数据项，并返回该数据项
// 如果集合为空，第二个范围值为false, 否则为true
func (c *GeneralCollection[T]) Pop() (T, bool) {
	return c.RemoveByIndex(-1)
}

// Shift 从集合头部移出一个数据项，并返回该数据项
// 如果集合为空，第二个范围值为false, 否则为true
func (c *GeneralCollection[T]) Shift() (T, bool) {
	return c.RemoveByIndex(0)
}

// AsSlice 将集合转换成切片并返回
func (c *GeneralCollection[T]) AsSlice() []T {
	if c.sliceCache == nil {
		c.sliceCache = make([]T, 0, len(c.orderedKeys))
		for _, key := range c.orderedKeys {
			c.tryAppendToSliceCache(c.items[key])
		}
	}
	return c.sliceCache
}

// AsMap 将集合转换成map并返回
func (c *GeneralCollection[T]) AsMap() map[string]T {
	m := map[string]T{}
	for key, val := range c.items {
		m[key] = val
	}
	return m
}

// ForEach 遍历每一个数据项，并交由给定的函数处理
func (c *GeneralCollection[T]) ForEach(iteratee func(each *ItemInfo[T])) {
	for idx, key := range c.orderedKeys {
		iteratee(&ItemInfo[T]{
			Index: idx,
			Key:   key,
			Item:  c.items[key],
		})
	}
}

// Every 尝试对每一个数据项使用给定的函数进行测试，当每一个测试结果都为true时, 返回true, 否则返回false
// 简而言之，该方法与一阶谓词逻辑中全称量词判断一样的效果
func (c *GeneralCollection[T]) Every(tester func(item T) bool) bool {
	for _, item := range c.items {
		if !tester(item) {
			return false
		}
	}
	return true
}

// Some 尝试对每一个数据项使用给定的函数进行测试，当任意一个数据项的测试结果为true时, 就返回true, 否则返回false
// 该方法与一阶谓词逻辑中存在量词判断一样的效果
func (c *GeneralCollection[T]) Some(tester func(item T) bool) bool {
	for _, item := range c.items {
		if tester(item) {
			return true
		}
	}
	return false
}

// GroupCount 根据给定的分组逻辑，计算出每个分组中数据项的数量, 拆分后的组的键由参数中的分组逻辑提供
func (c *GeneralCollection[T]) GroupCount(grouper func(each *ItemInfo[T]) string) *Group[int] {
	g := NewGroup[int]()
	for idx, key := range c.orderedKeys {
		groupKey := grouper(&ItemInfo[T]{
			Index: idx,
			Key:   key,
			Item:  c.items[key],
		})
		count, _ := g.Find(groupKey)
		g.Set(groupKey, count+1)
	}
	return g
}

// FilterCount 根据指定的过滤器, 返回符合条件的数据项数量
func (c *GeneralCollection[T]) FilterCount(filter func(each *ItemInfo[T]) bool) int {
	count := 0
	for idx, key := range c.orderedKeys {
		info := &ItemInfo[T]{
			Index: idx,
			Key:   key,
			Item:  c.items[key],
		}
		if filter(info) {
			count += 1
		}
	}
	return count
}

// Filter 使用给定的过滤函数过滤掉数据项, 并返回由剩余数据项组成的集合
// 该方法不会影响当前集合, 而是返回一个新集合
func (c *GeneralCollection[T]) Filter(filter func(each *ItemInfo[T]) bool) *GeneralCollection[T] {
	newCollection := NewGeneralCollection[T]()
	for idx, key := range c.orderedKeys {
		item := c.items[key]
		info := &ItemInfo[T]{
			Index: idx,
			Key:   key,
			Item:  item,
		}
		if filter(info) {
			if c.isAutoGenKey(key) {
				newCollection.Add(item)
			} else {
				newCollection.AddWithKey(item, key)
			}
		}
	}
	return newCollection
}

// SelfFilter 功能同Filter, 不过过滤掉的是当前集合中的数据项
func (c *GeneralCollection[T]) SelfFilter(filter func(each *ItemInfo[T]) bool) *GeneralCollection[T] {
	newColl := c.Filter(filter)
	c.init()
	c.items = newColl.items
	c.orderedKeys = newColl.orderedKeys
	c.autoGeneratedKeys = newColl.autoGeneratedKeys
	return c
}

// Sort 排序, 并返回排序后的集合
// 该方法不会影响当前集合, 而是会新生成一个排序后的集合
func (c *GeneralCollection[T]) Sort(less func(a T, b T) bool) *GeneralCollection[T] {
	collection := c.clone()
	return collection.SelfSort(less)
}

// SelfSort 同Sort, 不过对当前集合进行排序
func (c *GeneralCollection[T]) SelfSort(less func(a T, b T) bool) *GeneralCollection[T] {
	sort.Slice(c.orderedKeys, func(i, j int) bool {
		return less(c.items[c.orderedKeys[i]], c.items[c.orderedKeys[j]])
	})
	c.clearKeysIndex()
	c.clearSliceCache()
	return c
}

// Shuffle 打乱集合顺序, 并返回打乱顺序后的新集合
// 该方法不会影响当前集合, 而是会新生成一个打乱顺序的集合
func (c *GeneralCollection[T]) Shuffle() *GeneralCollection[T] {
	collection := c.clone()
	return collection.SelfShuffle()
}

// SelfShuffle 同Shuffle, 不过打乱的是当前集合的顺序
func (c *GeneralCollection[T]) SelfShuffle() *GeneralCollection[T] {
	count := c.Count()
	if count < 2 {
		return c
	}

	r := rand.New(rand.NewSource(time.Now().UnixNano()))
	// Fisher–Yates shuffle
	shuffleSlice := c.orderedKeys
	for i := count - 1; i > 0; i-- {
		idx := r.Intn(i + 1)
		shuffleSlice[idx], shuffleSlice[i] = shuffleSlice[i], shuffleSlice[idx]
	}
	c.clearSliceCache()
	return c
}

func (c *GeneralCollection[T]) actualIndex(idx int) (int, bool) {
	if idx < 0 {
		idx = len(c.orderedKeys) + idx
		if idx < 0 {
			return 0, false
		}
	} else if idx > len(c.orderedKeys)-1 {
		return 0, false
	}
	return idx, true
}

func (c *GeneralCollection[T]) clone() *GeneralCollection[T] {
	newCollection := NewGeneralCollection[T]()
	for _, key := range c.orderedKeys {
		item := c.items[key]
		if c.isAutoGenKey(key) {
			newCollection.Add(item)
		} else {
			newCollection.AddWithKey(item, key)
		}
	}
	return newCollection
}

func (c *GeneralCollection[T]) setKeyIndex(key string, idx int) {
	if c.keysIndex != nil {
		c.keysIndex[key] = idx
	}
}

func (c *GeneralCollection[T]) deleteKeyIndex(key string) {
	if c.keysIndex != nil {
		delete(c.keysIndex, key)
	}
}

func (c *GeneralCollection[T]) clearKeysIndex() {
	c.keysIndex = nil
}

func (c *GeneralCollection[T]) trySetSliceCacheItem(idx int, item T) {
	if c.sliceCache != nil && idx >= 0 && idx < len(c.sliceCache) {
		c.sliceCache[idx] = item
	}
}

func (c *GeneralCollection[T]) tryAppendToSliceCache(item T) {
	if c.sliceCache != nil {
		c.sliceCache = append(c.sliceCache, item)
	}
}

func (c *GeneralCollection[T]) clearSliceCache() {
	c.sliceCache = nil
}

func (c *GeneralCollection[T]) isAutoGenKey(key string) bool {
	_, ok := c.autoGeneratedKeys[key]
	return ok
}

func (c *GeneralCollection[T]) genKey() string {
	for {
		key := "_autogen_" + uuid.New().String()
		if _, ok := c.items[key]; !ok {
			return key
		}
	}
}
